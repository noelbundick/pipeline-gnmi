// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mpls_te_soft_preemption_stats.proto

package cisco_ios_xr_mpls_te_oper_mpls_te_soft_preemption_statistics

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Soft preemption stats
type MplsTeSoftPreemptionStats_KEYS struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MplsTeSoftPreemptionStats_KEYS) Reset()         { *m = MplsTeSoftPreemptionStats_KEYS{} }
func (m *MplsTeSoftPreemptionStats_KEYS) String() string { return proto.CompactTextString(m) }
func (*MplsTeSoftPreemptionStats_KEYS) ProtoMessage()    {}
func (*MplsTeSoftPreemptionStats_KEYS) Descriptor() ([]byte, []int) {
	return fileDescriptor_mpls_te_soft_preemption_stats_e062f588dc497cdc, []int{0}
}
func (m *MplsTeSoftPreemptionStats_KEYS) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS.Unmarshal(m, b)
}
func (m *MplsTeSoftPreemptionStats_KEYS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS.Marshal(b, m, deterministic)
}
func (dst *MplsTeSoftPreemptionStats_KEYS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS.Merge(dst, src)
}
func (m *MplsTeSoftPreemptionStats_KEYS) XXX_Size() int {
	return xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS.Size(m)
}
func (m *MplsTeSoftPreemptionStats_KEYS) XXX_DiscardUnknown() {
	xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS.DiscardUnknown(m)
}

var xxx_messageInfo_MplsTeSoftPreemptionStats_KEYS proto.InternalMessageInfo

type MplsTeSoftPreemptionStats struct {
	// The timestamp when these stats are cleared relative to Jan 1, 1970
	LastClearedTimestamp uint32 `protobuf:"varint,50,opt,name=last_cleared_timestamp,json=lastClearedTimestamp" json:"last_cleared_timestamp,omitempty"`
	// The number of soft preemption events triggered
	SoftPreemptionEvents uint32 `protobuf:"varint,51,opt,name=soft_preemption_events,json=softPreemptionEvents" json:"soft_preemption_events,omitempty"`
	// The number of LSPs that have been soft preempted at this node
	SoftPreemptedLsPs uint32 `protobuf:"varint,52,opt,name=soft_preempted_ls_ps,json=softPreemptedLsPs" json:"soft_preempted_ls_ps,omitempty"`
	// The number of LSPs that have been soft preempted and timed out at this node
	TimedOutSoftPreemptedLspSs uint32 `protobuf:"varint,53,opt,name=timed_out_soft_preempted_lsp_ss,json=timedOutSoftPreemptedLspSs" json:"timed_out_soft_preempted_lsp_ss,omitempty"`
	// The number of LSPs that have been soft preempted at this node and torn down before timing out
	TornDownSoftPreemptedLsPs uint32 `protobuf:"varint,54,opt,name=torn_down_soft_preempted_ls_ps,json=tornDownSoftPreemptedLsPs" json:"torn_down_soft_preempted_ls_ps,omitempty"`
	// The number of LSPs that have been soft preempted and then fast rerouted at this node
	FrrTriggeredSoftPreemptedLspSs uint32 `protobuf:"varint,55,opt,name=frr_triggered_soft_preempted_lsp_ss,json=frrTriggeredSoftPreemptedLspSs" json:"frr_triggered_soft_preempted_lsp_ss,omitempty"`
	// The minimum number of seconds an LSP remained in the soft preempted state
	MinimumTimeInSoftPreemptedState uint32 `protobuf:"varint,56,opt,name=minimum_time_in_soft_preempted_state,json=minimumTimeInSoftPreemptedState" json:"minimum_time_in_soft_preempted_state,omitempty"`
	// The maximum number of seconds an LSP remained in the soft preempted state without being hard preempted
	TimeInSoftPreemptedStateMax uint32 `protobuf:"varint,57,opt,name=time_in_soft_preempted_state_max,json=timeInSoftPreemptedStateMax" json:"time_in_soft_preempted_state_max,omitempty"`
	// The average number of seconds an LSP remained in the soft preempted state. This excludes the timed out LSPs
	TimeInSoftPreemptedStateAvg uint32 `protobuf:"varint,58,opt,name=time_in_soft_preempted_state_avg,json=timeInSoftPreemptedStateAvg" json:"time_in_soft_preempted_state_avg,omitempty"`
	// Number of soft preempted LSPs at the headend. This is relevant to the headend
	SoftPreemptedHeadLsPs uint32 `protobuf:"varint,59,opt,name=soft_preempted_head_ls_ps,json=softPreemptedHeadLsPs" json:"soft_preempted_head_ls_ps,omitempty"`
	// Number of soft preemption LSPs that are reoptimized. This is relevant to the headend
	ReoptimizedSoftPreemptedLsPs uint32 `protobuf:"varint,60,opt,name=reoptimized_soft_preempted_ls_ps,json=reoptimizedSoftPreemptedLsPs" json:"reoptimized_soft_preempted_ls_ps,omitempty"`
	// Number of soft preemption LSPs that are torn down instead of being reoptimized. This is relevant to the headend.
	// uint32 torndown_soft_preempted_ls_ps = 61;
	// Number of soft preemption LSPs that are replaced with the path protection LSP. This is relevant to the headend
	PathProtectedSwitchoverSoftPreemptedLsPs uint32   `protobuf:"varint,62,opt,name=path_protected_switchover_soft_preempted_ls_ps,json=pathProtectedSwitchoverSoftPreemptedLsPs" json:"path_protected_switchover_soft_preempted_ls_ps,omitempty"`
	XXX_NoUnkeyedLiteral                     struct{} `json:"-"`
	XXX_unrecognized                         []byte   `json:"-"`
	XXX_sizecache                            int32    `json:"-"`
}

func (m *MplsTeSoftPreemptionStats) Reset()         { *m = MplsTeSoftPreemptionStats{} }
func (m *MplsTeSoftPreemptionStats) String() string { return proto.CompactTextString(m) }
func (*MplsTeSoftPreemptionStats) ProtoMessage()    {}
func (*MplsTeSoftPreemptionStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_mpls_te_soft_preemption_stats_e062f588dc497cdc, []int{1}
}
func (m *MplsTeSoftPreemptionStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MplsTeSoftPreemptionStats.Unmarshal(m, b)
}
func (m *MplsTeSoftPreemptionStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MplsTeSoftPreemptionStats.Marshal(b, m, deterministic)
}
func (dst *MplsTeSoftPreemptionStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MplsTeSoftPreemptionStats.Merge(dst, src)
}
func (m *MplsTeSoftPreemptionStats) XXX_Size() int {
	return xxx_messageInfo_MplsTeSoftPreemptionStats.Size(m)
}
func (m *MplsTeSoftPreemptionStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MplsTeSoftPreemptionStats.DiscardUnknown(m)
}

var xxx_messageInfo_MplsTeSoftPreemptionStats proto.InternalMessageInfo

func (m *MplsTeSoftPreemptionStats) GetLastClearedTimestamp() uint32 {
	if m != nil {
		return m.LastClearedTimestamp
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetSoftPreemptionEvents() uint32 {
	if m != nil {
		return m.SoftPreemptionEvents
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetSoftPreemptedLsPs() uint32 {
	if m != nil {
		return m.SoftPreemptedLsPs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetTimedOutSoftPreemptedLspSs() uint32 {
	if m != nil {
		return m.TimedOutSoftPreemptedLspSs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetTornDownSoftPreemptedLsPs() uint32 {
	if m != nil {
		return m.TornDownSoftPreemptedLsPs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetFrrTriggeredSoftPreemptedLspSs() uint32 {
	if m != nil {
		return m.FrrTriggeredSoftPreemptedLspSs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetMinimumTimeInSoftPreemptedState() uint32 {
	if m != nil {
		return m.MinimumTimeInSoftPreemptedState
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetTimeInSoftPreemptedStateMax() uint32 {
	if m != nil {
		return m.TimeInSoftPreemptedStateMax
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetTimeInSoftPreemptedStateAvg() uint32 {
	if m != nil {
		return m.TimeInSoftPreemptedStateAvg
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetSoftPreemptedHeadLsPs() uint32 {
	if m != nil {
		return m.SoftPreemptedHeadLsPs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetReoptimizedSoftPreemptedLsPs() uint32 {
	if m != nil {
		return m.ReoptimizedSoftPreemptedLsPs
	}
	return 0
}

func (m *MplsTeSoftPreemptionStats) GetPathProtectedSwitchoverSoftPreemptedLsPs() uint32 {
	if m != nil {
		return m.PathProtectedSwitchoverSoftPreemptedLsPs
	}
	return 0
}

func init() {
	proto.RegisterType((*MplsTeSoftPreemptionStats_KEYS)(nil), "cisco_ios_xr_mpls_te_oper.mpls_te.soft_preemption.statistics.mpls_te_soft_preemption_stats_KEYS")
	proto.RegisterType((*MplsTeSoftPreemptionStats)(nil), "cisco_ios_xr_mpls_te_oper.mpls_te.soft_preemption.statistics.mpls_te_soft_preemption_stats")
}

func init() {
	proto.RegisterFile("mpls_te_soft_preemption_stats.proto", fileDescriptor_mpls_te_soft_preemption_stats_e062f588dc497cdc)
}

var fileDescriptor_mpls_te_soft_preemption_stats_e062f588dc497cdc = []byte{
	// 427 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x86, 0xc5, 0xa5, 0x87, 0x95, 0x38, 0x60, 0x15, 0xe4, 0xf2, 0xd1, 0x46, 0x69, 0x0f, 0x3d,
	0x19, 0x89, 0x16, 0x28, 0x50, 0x21, 0x55, 0x25, 0x08, 0x54, 0x2a, 0x22, 0xdc, 0x0b, 0xa7, 0x61,
	0xb1, 0x27, 0xce, 0x4a, 0x5e, 0xef, 0x6a, 0x67, 0xe2, 0x44, 0xfc, 0x4c, 0x7e, 0x11, 0xda, 0x4d,
	0x1c, 0x25, 0xb1, 0x71, 0x8f, 0xd6, 0xbc, 0xcf, 0xb3, 0xe3, 0x77, 0xb5, 0xe2, 0x58, 0xdb, 0x92,
	0x80, 0x11, 0xc8, 0x4c, 0x18, 0xac, 0x43, 0xd4, 0x96, 0x95, 0xa9, 0x80, 0x58, 0x32, 0x25, 0xd6,
	0x19, 0x36, 0xd1, 0x65, 0xa6, 0x28, 0x33, 0xa0, 0x0c, 0xc1, 0xc2, 0x41, 0x43, 0x18, 0x8b, 0x2e,
	0x59, 0x7d, 0x24, 0x3b, 0x78, 0xe2, 0x71, 0x45, 0xac, 0x32, 0x1a, 0x9e, 0x88, 0x61, 0xef, 0x21,
	0x70, 0x33, 0xfa, 0x99, 0x0e, 0xff, 0xee, 0x89, 0x17, 0xbd, 0xb1, 0xe8, 0x5c, 0x3c, 0x29, 0x25,
	0x31, 0x64, 0x25, 0x4a, 0x87, 0x39, 0xb0, 0xd2, 0x48, 0x2c, 0xb5, 0x8d, 0x5f, 0x0d, 0x1e, 0x9c,
	0x3e, 0xfc, 0xb1, 0xef, 0xa7, 0xd7, 0xcb, 0xe1, 0x5d, 0x33, 0xf3, 0xd4, 0xae, 0x0e, 0x6b, 0xac,
	0x98, 0xe2, 0xb3, 0x25, 0xe5, 0xa7, 0xe3, 0xf5, 0x70, 0x14, 0x66, 0xd1, 0x4b, 0xb1, 0xbf, 0x49,
	0x61, 0x0e, 0x25, 0x81, 0xa5, 0xf8, 0x3c, 0x30, 0x8f, 0x36, 0x18, 0xcc, 0xbf, 0xd1, 0x98, 0xa2,
	0x6b, 0x71, 0xe4, 0xf7, 0xc9, 0xc1, 0xcc, 0x18, 0x5a, 0xa8, 0x05, 0xa2, 0xf8, 0x75, 0x60, 0x9f,
	0x86, 0xd8, 0xf7, 0x19, 0xa7, 0xdb, 0x0e, 0x9b, 0x52, 0x74, 0x25, 0x0e, 0xd9, 0xb8, 0x0a, 0x72,
	0x33, 0xaf, 0xa0, 0xf3, 0xfc, 0x37, 0xc1, 0x71, 0xe0, 0x53, 0x9f, 0xcc, 0xbc, 0x4a, 0x5b, 0x7b,
	0xdc, 0x88, 0xe3, 0x89, 0x73, 0xc0, 0x4e, 0x15, 0x05, 0xfa, 0x96, 0xba, 0x77, 0x79, 0x1b, 0x3c,
	0x87, 0x13, 0xe7, 0xee, 0x9a, 0x64, 0xc7, 0x3e, 0xb7, 0xe2, 0x44, 0xab, 0x4a, 0xe9, 0x99, 0x0e,
	0x65, 0x83, 0x6a, 0x6d, 0xe5, 0x6f, 0x06, 0xe3, 0x8b, 0x60, 0x3b, 0x5a, 0x65, 0x7d, 0xf7, 0x5f,
	0xb7, 0x57, 0x4b, 0x7d, 0x2c, 0x1a, 0x89, 0x41, 0x9f, 0x06, 0xb4, 0x5c, 0xc4, 0xef, 0x82, 0xea,
	0x19, 0xff, 0xc7, 0x71, 0x2b, 0x17, 0xf7, 0x6a, 0x64, 0x5d, 0xc4, 0xef, 0xfb, 0x35, 0x57, 0x75,
	0x11, 0x5d, 0x88, 0x83, 0x1d, 0x7c, 0x8a, 0xb2, 0xe9, 0xf9, 0x43, 0xe0, 0x1f, 0x6f, 0xdd, 0xf3,
	0x17, 0x94, 0xcb, 0x8e, 0x3f, 0x8b, 0x81, 0x43, 0x63, 0x59, 0x69, 0xf5, 0xa7, 0xab, 0x61, 0x2f,
	0xb8, 0x0c, 0x82, 0xe7, 0x1b, 0xb9, 0xf6, 0x5d, 0xfd, 0x12, 0x89, 0x95, 0x3c, 0x05, 0xff, 0xc8,
	0x30, 0x0b, 0x3f, 0x30, 0x57, 0x9c, 0x4d, 0x4d, 0x8d, 0xae, 0xdb, 0xfa, 0x31, 0x58, 0x4f, 0x3d,
	0x35, 0x6e, 0xa0, 0x74, 0xcd, 0xb4, 0x4e, 0xf8, 0xbd, 0x17, 0xde, 0xef, 0xd9, 0xbf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xc7, 0xfd, 0x08, 0xc3, 0xe6, 0x03, 0x00, 0x00,
}
